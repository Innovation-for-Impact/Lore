import contextlib
from typing import Any, ClassVar, Protocol, cast

from django.urls import reverse
from rest_framework import serializers

from lore import models


class HALSerializerMixin(serializers.Serializer):
    """A mixin to extend a serializer with the HAL guidelines.

    To use, first add the `_links` field to the Meta `fields`.
    Then, specify `include_urls` in the Meta class. Each item in this
    iterable specifies a url that will be included in `_links`.

    The `self` can be included in `include_urls` without neeeding to
    implement anything else. Any additional fields will require an
    attribute declared in the base serializer class (outside of Meta)
    following the naming convention `get_<include_url_item_name>_url`.

    The current implementation expects these to be the full urls.
    """

    _links = serializers.SerializerMethodField()

    class SerializerProtocol(Protocol):
        """Enforces specific properties to use this mixin.

        This can be satisfied by deriving from model serializer
        """

        url_field_name: str  # Required for type checking

        def build_url_field(
            self,
            field_name: str,
            field_class: type,
        ) -> tuple[type, dict]:
            """Build url class specified on the ModelSerializer."""
            ...

    def get_self_url(
        self: SerializerProtocol,
        obj: models.LoreGroup,
    ) -> serializers.Hyperlink:
        """Create the url referencing this object."""
        # This is about an hour of reverse engineering DRF's system.
        # I wanted to isolate just the url without doing anything special, and
        # here we are.
        #
        # Some behavior on the orignal parser is ommited. More specifically,
        # the extra_kwargs. If you need those for the url... you shouldn't
        field_class, field_kwargs = self.build_url_field(
            self.url_field_name,
            obj.__class__,
        )
        url_field = field_class(**field_kwargs)
        url_field.bind(self.url_field_name, self)
        return cast(serializers.Hyperlink, url_field.to_representation(obj))

    def get__links(self: SerializerProtocol, obj: models.LoreGroup) -> dict:
        """Build link mapping from specified `include_urls`.

        If `include_urls` is not specified, then nothing is included.
        Expects attributes of the name `get_{include_url[i]_url}`.
        """
        urls = {}
        meta = getattr(self, "Meta", None)
        if meta is None:
            return {}
        for url in getattr(meta, "include_urls", []):
            get_url = getattr(self, f"get_{url}_url", None)
            if get_url is not None:
                urls[url] = {"href": get_url(obj)}
            else:
                url_field = getattr(self, f"{url}_url")
                url_field.bind(f"{url}_url", self)
                print(url_field.to_representation(obj.related))
        return urls


class QuoteSerializer(serializers.ModelSerializer, HALSerializerMixin):
    """Serializer for the quote detail.

    Serializes the quote's:
      - id
      - text
      - said_by
      - said_by_url
      - group
      - group_url
      - created
      - url
    """

    _links = serializers.SerializerMethodField()
    said_by_url = serializers.HyperlinkedRelatedField(
        view_name="loreuser-detail",
        lookup_field="pk",
        many=False,
        read_only=True,
        source="said_by",
    )
    group_url = serializers.HyperlinkedRelatedField(
        view_name="loregroup-detail",
        lookup_field="pk",
        many=False,
        read_only=True,
        source="group",
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        try:
            # get userse that are only in the shared group
            user: models.LoreUser = cast(
                models.LoreUser,
                self.context["request"].user,
            )

            self.fields["said_by"] = serializers.PrimaryKeyRelatedField(
                queryset=user.get_mutual_users(),
                read_only=False,
            )
            self.fields["group"] = serializers.PrimaryKeyRelatedField(
                read_only=True,
            )
        except KeyError:
            pass

    def create(self, validated_data: dict[Any, Any]) -> models.Quote:
        """Create an instane of an Quote."""
        return models.Quote.quotes.create_quote(
            text=validated_data["text"],
            said_by_pk=validated_data["said_by"].pk,
            group=validated_data["group"],
        )

    class Meta:
        model = models.Quote
        fields: ClassVar[list[str]] = [
            "_links",
            "id",
            "text",
            "said_by",
            "said_by_url",
            "group_url",
            "group",
            "created",
        ]
        include_urls = ["self", "group"]


class ImageSerializer(serializers.ModelSerializer):
    """Serializer for the image detail.

    Serializes the images's:
      - id
      - image
      - description
      - group
      - group_url
      - created
      - url
    """

    group_url = serializers.HyperlinkedRelatedField(
        view_name="loregroup-detail",
        lookup_field="pk",
        many=False,
        read_only=True,
        source="group",
    )
    description = serializers.CharField(required=False)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        with contextlib.suppress(KeyError):
            self.fields["group"] = serializers.PrimaryKeyRelatedField(
                read_only=True,
            )

    def create(self, validated_data: dict[Any, Any]) -> models.Image:
        """Create an instane of an Image."""
        return models.Image.images.create_image(
            image=validated_data["image"],
            description=validated_data.get("description"),
            group=validated_data["group"],
        )

    class Meta:
        model = models.Image
        fields: ClassVar[list[str]] = [
            "id",
            "image",
            "description",
            "group",
            "group_url",
            "created",
            "url",
        ]


# TODO : add achieved urls to serializer
class AchievementSerializer(serializers.ModelSerializer, HALSerializerMixin):
    """Serializer for the achievement detail.

    Serializes the images's:
      - id (read only)
      - title
      - image
      - description
      - achieved_by (write only)
      - achieved_by_url (read only)
      - group (read only)
      - group_url (read only)
      - created (read only)
      - url (read only)
    """

    group_url = serializers.HyperlinkedRelatedField(
        view_name="loregroup-detail",
        lookup_field="pk",
        many=False,
        read_only=True,
        source="group",
    )
    image = serializers.ImageField(required=False)
    achieved_by_url = serializers.SerializerMethodField()
    num_achieved = serializers.ReadOnlyField()

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        print(dir(self))
        with contextlib.suppress(KeyError):
            self.fields["group"] = serializers.PrimaryKeyRelatedField(
                read_only=True,
            )

    def create(self, validated_data: dict[Any, Any]) -> models.Achievement:
        """Create an instane of an Image."""
        return models.Achievement.achievements.create_achievement(
            title=validated_data["title"],
            image=validated_data.get("image"),
            description=validated_data["description"],
            achieved_by=validated_data.get("achieved_by", []),
            group=validated_data["group"],
        )

    def get_achieved_by_url(self, obj: models.Achievement) -> str:
        """Create a url resource to the users that achieved this."""
        url = self.context["request"].build_absolute_uri(
            reverse("loreuser-list"),
        )
        return f"{url}?achievement={obj.pk}"

    class Meta:
        model = models.Achievement
        fields: ClassVar[list[str]] = [
            "_links",
            "id",
            "title",
            "image",
            "description",
            "achieved_by",
            "achieved_by_url",
            "num_achieved",
            "group",
            "group_url",
            "created",
            "url",
        ]
        extra_kwargs: ClassVar[dict[str, dict[str, Any]]] = {
            "achieved_by": {"write_only": True, "allow_empty": True},
        }
        include_urls = ["self", "group"]


class AchievementUpdateSerializer(AchievementSerializer):
    """Limits what achievement fields can be updated.

    Achieved_by is read only
    """

    class Meta(AchievementSerializer.Meta):
        fields: ClassVar[list[str]] = [
            f
            for f in AchievementSerializer.Meta.fields
            if f not in ["achieved_by"]
        ]
        read_only_fields: ClassVar[list[str]] = ["achieved_by"]
        extra_kwargs: ClassVar[dict[str, dict[str, Any]]] = {}


# TODO: add leave url to group
class GroupSerializer(
    serializers.ModelSerializer,
    HALSerializerMixin,
):
    """Serializes a group.

    Provides the following fields:
    - id (read only)
    - name
    - members_url (read only)
    - join_code (read only)
    - avatar
    - created (read only)
    - url (read only)
    - members (write only)
    """

    def get_members_url(self, obj: models.LoreGroup) -> str:
        """Create a url resource to the members in the group."""
        base_url = self.context["request"].build_absolute_uri(
            reverse("loreuser-list"),
        )
        return f"{base_url}?member_of={obj.pk}"

    def get_achievements_url(self, obj: models.LoreGroup) -> str:
        """Create a url resource to the achievements in the group."""
        base_url = self.context["request"].build_absolute_uri(
            reverse("achievement-list"),
        )
        return f"{base_url}?group_id={obj.pk}"

    def get_quotes_url(self, obj: models.LoreGroup) -> str:
        """Create a url resource to the quotes in the group."""
        base_url = self.context["request"].build_absolute_uri(
            reverse("quote-list"),
        )
        return f"{base_url}?group_id={obj.pk}"

    def get_images_url(self, obj: models.LoreGroup) -> str:
        """Create a url resource to the images in the group."""
        base_url = self.context["request"].build_absolute_uri(
            reverse("image-list"),
        )
        return f"{base_url}?group_id={obj.pk}"

    def get_leave_url(self, obj: models.LoreGroup) -> str:
        base_url = self.context["request"].build_absolute_uri(
            reverse("loregroup-leave", args=[obj.pk]),
        )
        return f"{base_url}"

    def create(self, validated_data: dict[Any, Any]) -> models.LoreGroup:
        """Create an instane of an Group."""
        return models.LoreGroup.groups.create_group(
            name=validated_data["name"],
            owner=self.context["request"].user,
            avatar=validated_data.get("avatar"),
            members=validated_data.get("members", []),
        )

    class Meta:
        """Describes the serializer."""

        model = models.LoreGroup
        fields: ClassVar[list[str]] = [
            "_links",
            "id",
            "name",
            "members",
            "num_members",
            "join_code",
            "avatar",
            "created",
        ]
        read_only_fields: ClassVar[list[str]] = ["join_code"]
        extra_kwargs: ClassVar[dict[str, dict[str, Any]]] = {
            "members": {"write_only": True, "allow_empty": True},
        }
        include_urls: ClassVar[list[str]] = [
            "self",
            "quotes",
            "images",
            "members",
            "leave",
        ]


class GroupUpdateSerializer(GroupSerializer):
    """Serializer that limits what group fields can be updated.

    Members cannot be updated
    """

    class Meta(GroupSerializer.Meta):
        """Overwrite behavior on the orignal Meta."""

        model = models.LoreGroup
        fields: ClassVar[list[str]] = [
            f for f in GroupSerializer.Meta.fields if f not in ["members"]
        ]
        read_only_fields: ClassVar[list[str]] = ["join_code", "members"]
        extra_kwargs: ClassVar[dict[str, dict[str, Any]]] = {}


class UserSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = models.LoreUser
        fields = ["id", "first_name", "last_name", "avatar", "url"]
